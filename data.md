# データ

## ストレージエンジン
- ストレージエンジンとは、データベース内のデータを実際のバイトに変換して基盤となるファイル システムに保存する場所のこと
- インデックスの概念はメタデータを追加で横においておくこと
- OLTP(OnLine Transaction Processing)は莫大なリクエストを受けるけるのに適した処理であり、インデックスを使ってデータを検索する
- OLAP(OnLine Analytics Processing)は主にビジネスアナリストが使用し、クエリ1つの負荷が大きく、スキャンするレコード数が多い
- log-structuredはファイルへの追記と古いファイルの削除のみによるストレージエンジンのことで、SSTableや LSMツリーがある
- ハッシュインデックスは、セグメントファイルにキーバリューの文字列を追記し、インメモリにハッシュテーブルとしてキーとバイトオフセットを保持する方法
- SSTable(Sorted String Table)は、ハッシュインデックスのセグメントファイルとインメモリのテーブルをred-black Tree等を利用してキーの順でソートしたもの
- SSTableのマージはセグメントファイルをマージすることで、新しいキーのみが残す
- SSTableのコンパクションはインメモリのテーブルの最新キーのみを残すこと
- B(Balanced) Treeインデックスは、追加、更新、削除の都度ノードが一定以下になるよう保持できるデータ構造を利用したインデックス保持の仕組み
- write-ahedログはB Treeインデックスの追記のみをするログファイルであり、クラッシュ時に利用される
- 列指向のストレージはそれぞれの列に含まれるすべての値をまとめ、圧縮して保存している

## レプリケーション
- シングルリーダーアプリケーションは、クライアントは全ての書き込みを1つのリーダーに送り、リーダーはデータ変更イベントのストリームを他のフォロワーに送信する
- マルチリーダーレプリケーションは、クライアントが複数あるリーダーノードのいずれかに送信し、リーダー軍はデータの変更ストリームをお互いとそしてフォロワーに送信する
- リーダーレスレプリケーションは、クライアントは書き込みを複数のノードに送信し、古いデータを持つノードを修正するために読み取りを複数のノードから並列に行う
- レプリケーションはラグが生じるため、アプリケーションの状況に応じて一貫性モデルを採用する
- read-after-write一貫性は、自分自身が投入したデータを常に見ることができる
- monotonic reads(単調な読み取り)は、ある時点のデータをユーザーが一度見たら、それ以前の時点のデータを見ることが出来ない
- consistent prefix reads(一貫性のあるプレフィックス読み取り)は、ユーザーは適切な因果関係を保持した状態でデータを見ることができる

## パーティショニング
- パーティショニングの目標は、データやクエリの負荷を複数のマシン間で均等に分配し、ホットスポットが生じないようにすることである。データに適したパーティショニングのスキームを選択肢、クラスタへのノードの追加や削除が生じた時にリバランシングする
- キーの範囲によるパーティショニングは、キーがソートされ1つのパーティションには最小値〜最大値の間にあるキーが保存される
- ハッシュパーティショニングは、ハッシュ関数がキーに対して適用され1つのパーティションにはハッシュの一定の範囲が保存される

## トランザクション
- ACIDは、Atomicity, Consistency, Isolation, Durabilityのこと
- Atomicityは、それ以上小さな部分に分割できないものを指す。システムがとりえる状態はその処理が始まる前と終わった後の状態だけであり、中間の状態にはならないこと
- Consistencyは、データについて常に真でなければならないルールを維持すること。このルールの概念はアプリケーションに依存している
- Isolationは、並行して実行されたトランザクションが互いから分離されていること
- Durabilityは、データを失わず保持し続けることで、HDDやSSDなどの不揮発性のストレージに書きこむこと
- トランザクションには分離レベルがあり、弱い順に、Read Committed、Snapshot Isolation、Serializabilityがある。
- Dirty Readは、あるクライアントがまだコミットされていない書き込みを読むこと。read committed以上の分離レベルで回避できる
- Dirty Writeは、あるクライアントがまだコミットされていない書き込みの内容を上書きすること。ほぼすべてのトランザクションで生じない
- Read Skew(nonrepeatable read)は、クライアントが異なる時刻にデータベースの異なる部分を見ること。スナップショット分離レベルで回避できる
- Write Skewは、トランザクション内で読み取り、その値に基づいて判断を下しその結果をデータベースに書き込む際に、書き込み時に判断の根拠となった読み取りが真ではなくなること。直列化可能レベルで回避できる
- 更新ロストは、2つの並行するトランザクションが並行して、何らかの値をデータベースから読み取り、その値を変更して書き戻す際に、2つめの書き込みが1つめの書き込みを踏まえておらず変更の1つが失われること。`SELECT FOR UPDATE`によるロックで回避する
- Phantom Readは、トランザクションが何らかの検索条件にマッチするオブジェクトを読み取り、他のクライアントはその検索結果に影響する書き込みを行うこと。インデックス範囲ロックのような対応が必要
- Read Committedは、トランザクションの最も基本的な分離レベルであり下記を保証する
  - データベースから読み取ったデータはコミットされたデータのみであること(ダーティーリートは生じない)
  - データベースへの書き込みは、上書きするのはコミットされたデータのみであること(ダーティーライトは生じない)
- Snapshot Isolation(Repeatable Read)は、Read Committedより強固な一貫性を保持するトランザクションの分離レベルで、トランザクションが読み取るデータはすべてそのトランザクションの開始時点のデータベースにコミット済みのものだけであることを保証する
- MVCC(multi-version concurrency control)はSnapshot Isolationのデータベースの実装方法の1つであり、オブジェクトの複数のコミット済みバージョンを保持している
- Serializability(直列化可能レベル)は最も強い分離レベルであり、並行して実行されたトランザクションが、最終的にそれぞれが1つずつ順番に実行された結果となること
- 2 Pahaise Lock(悲観的ロック)は、Serializabilityを提供するトランザクションの実装方法であり、並行トランザクションにおいてライターがリーダーをブロックし、リーダーがライターをブロックする。読み取り用のShared(共有)ロックとExclusive(排他)ロックで実装される
- Predicate Lock(述語ロック)は、検索クエリにマッチするすべての行へのアクセスのロックのこと
- Range Lock(インデックス範囲ロック)は、述語ロックを単純化したもので、検索クエリの中でインデックスを張っている行をロックすること
